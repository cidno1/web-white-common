---
layout: post
title:  "CodeSquad"
date:   2017-01-05 21:17:00 +0900
---

# 코드스쿼드

```
잘 하기 위한 방법

- 배운 것을 가지고 다른 것을 계속 만들기
- 중학생 동생과 그 분야의 대가 앞에서 설명해보기
- 금요일도 와서 공부할 수 있으니 열심히 공부할 것

커뮤니케이션 채널

- 강의 카페 - Schololgy
- 커뮤니케이션 - Slack
- 온라인 Q&A - Piazza
- 프로젝트 관리  - Github

질문하는 방법

- 질문하기 전 3번 정도 다른 시도
- 질문하기 전 검색 ( 구글, 스택오버플로우 )
- 그 후 질문 ( 내뱉기 전 한 번 읽어볼 것 )
  - 구체적이고 명확한 질문 제목
  - 자세한 상황 설명 ( 플랫폼, 운영체제, 사용 언어 )
  - 소스코드는 gist, pastebin
  - 맞춤법 + 예의 바르게는 기본
  - 질문을 올렸다면 추적할 것

매일 공부해야 할 것들

- 영어/코딩/운동/독서

마스터들 닉네임

- 크롱(Front)
- 호눅스(Common, Back)
- JK(iOS)
```

---

### 170102

##### 리눅스 명령어

```
리눅스 커널의 다양한 배포판이 있음, 국내에서 가장 많이 쓰이는 것은 Ubuntu

history로 확인한 뒤, !1105 를 입력하면 그 번호에 해당하는 명령어를 다시 동작시킬 수 있음

say "hello" 하면 hello 라고 소리가 난다

echo "Hello" > Hello.txt

cat 파일 내용 표시

ctrl + U 를 누르면 명령줄을 삭제할 수 있다

find ‐name "파일 이름" : 파일명 검색

vim adventures

자연적 소리 sound
인위적 소리 audio

1 켜짐, 0 꺼짐
AND 곱, OR 합

코드 = 숫자

CS와 별도로 내가 관심있어하는 도메인을 가지고 있는 것이 좋음

이곳이 학원이 아니라 직장(베이스캠프)이라고 생각할 것

내 성장의 동력은 나

내가 무엇을 하고 싶은지에 대한 목표점에 관한 큰 그림을 스스로 그려나가야 함

해보지 않으면 알 수 없는 것들 투성이
```
---

### 170103

```
브라우저에서 지원되지 않으면 비표준(=플래시 같은)
플러그인을 설치해야 활용할 수 있음

뒤에 example 또는 tutorial 을 넣어서 검색하는 것도 방법 (simple 등)

역시 MDN이 좋다 (검색어에 mdn 넣을 것)
영어로 읽는 습관을 들여라

우선 코드 -> 서머리부터 읽어볼 것
그 후 바로 코드를 실행해보면서 이해할 것

디버깅을 위해서 개발자 도구 활용
=> 에러가 무엇인지 명확히 알려줌

문제가 생기면 바로 검색을 하라

깃헙주소와 더불어, 스택오버플로우 내역을 요구하는 해외 기업도 있음

parser를 통해 코드를 문자 단위로 잘게 나눔
그것을 기반으로 컴퓨터가 해석할 수 있도록 변환 bytecode
그걸 해석하면서 출력 interpreter

생각보다 null, undefined가 중요하다

javascript type check 로 검색해보면, typeof 의 한계를 알게 된다

문자열은 ""을 쓸 것

오류를 무시하지 말고, 찬찬히 들여다볼 것
오류 내용을 이해하라

소프트웨어 공학 두 개의 축 : 테스트 / 프로세스(개발 방법론, 협업)

테스트 자동화를 잘 하면 면접 때 대단한 플러스 요인

방법보다 방법론이 왜 나왔는지가 중요하다

당장 문제가 발생하지 않더라도, 잠재적 오류가 있을 수 있다
의도한 것이 아닌데, 오류를 내뱉지 않는 경우도 있다(버그의 일종)

포괄적인 의미의 디자인을 우선시하라
디자인 & 코드 ( 설계 )

변수선언, 사칙연산

console.log prints the element in an HTML-like tree
console.dir prints the element in a JSON-like tree

console은 객체이다

{} : 브레이스

아무 생각없이 메소드를 사용하지 말 것
왜 console이 필요한가?

JS에서는 네임스페이스를 객체로 표현함 ( 객체의 활용방안 )
충돌을 방지하기 위한 이름 공간 구획

console.log("a 더하기 b는 이것입니다. " + c);

c 를 type casting 해서 오류가 나오지 않은 것 ( 암묵적 형변환 )
JS의 특징이다

연산자 우선순위

type casting을 외우려고 하지 말고 그저 느껴서 익힐 것

JS의 모든 함수는 결과값을 리턴하는데, 그것이 정의되어있지 않으면 undefined 반환

jsbin.com
codepen.io

동적 타이핑
dynamic type

arguments.length

에러는 가능한 일찍 출력해줄 것

디버깅을 위해서는 정해진 메소드일지라도 변수에 담아두는 것이 좋다

함수 내 기능 코드가 너무 길어질 경우, 함수로 독립시켜서 만들 것

오류상황을 위로 올릴 것

로직 안에 데이터가 들어가있어선 안 된다 (메시지 등)

debugger; 를 추가하고, scope란을 확인해볼 것
브레이크 포인트를 찍고 함수를 돌려봐서 확인할 수도 있다
(인터프리터 언어다보니, 컴파일 과정이 없어서, 브레이크 포인트로 확인하는 과정이 많이 필요하다)

읽기 좋은 코드, 네이밍이 좋은 코드가 되기 위해 계속 지우고 새로 만들어볼 것

If 안 if를 없애라
```

---

### 170104
```
일급함수 일급객체에 대해서 조사해볼 것

결합도가 낮은 코드가 좋은 코드이다

함수를 최대한 작게 담백하게

같은 것을 여러 번 다시 짜는 것이 참 좋습니다
매번 설계를 새로 하면서 코드가 점점 더 좋아집니다

남들에게 설명했을 때 이해가 잘 되는 코드가 좋은 코드입니다

펑션을 잘 이해하고 있느냐가 중요한 실력 평가의 척도

함수 결과의 true false를 변수에 담아서 보여주게 되면, 디버깅할 때 보다 수월하다

Stack이 무엇인가?

크롬 개발자 도구를 통해 디버깅하는 습관을 들이세요

디버깅을 하면서 자바스크립트를 익히세요

함수를 변수에 담을 수 있고, 반환할 수 있다

네임스페이스는 객체에 쓰는 표현

전역변수는 window라는 객체에 담긴다

전역변수를 쓰지 말고, 필요에 따라서 지역변수를 쓰거나 매개변수로 넘겨주는 것이 좋다

함수 안에 함수가 있을 때, 안쪽 함수에서는 바깥 함수의 변수에 접근할 수 있지만, 바깥 함수에서는 안쪽 함수의 변수에 접근할 수 없다
스코프 체인(제일 가까운 스코프에서 찾는 변수가 없으면 바로 위 스코프로 가서 찾아본다)

오늘 배운 내용 : 디버깅, 스코프
```

##### 프로젝트별로 깃헙 계정을 다르게 쓰는 방법
```
git config user.name Eclatant
git config user.email distinct19@gmail.com
위 명령어 입력을 통해 계정을 수정한 후,

.git/config url에서 github.com 앞에 아이디를 추가해야 함 ( ex url : https://Eclatant@github.com/Eclatant )
```

---

### 170105

```
토큰 : 파싱하기 위해 잘라진 하나 하나의 요소
JS는 타입이 없는 것이 아니라 나중에 결정되는 것이다
문자열, 숫자, boolean, array, 배열, 오프젝트, null, regularExpression, function 등
마법같이 자동으로 되는 것은 없다
키워드와 예약어를 외우지 말고, 활용하다가 디버깅 과정으로 체득할 것
주석은 남들에게 코드로 전달하기 어려운 코드일 때만 부가적으로 필요하다 (분명한 이유가 필요하다)
프로세스의 분리를 위해서 함수가 필요한 때도 있다 (if 또는 for문을 줄이는 등, 의존성 약화)
핵심을 반영한 함수명으로 커버되지 않는 범위일 때 다른 함수로 독립시킨다
줄 수보다 과정이 핵심이다, 길더라도 의미적으로 쉽게 파악되는 것이 훨씬 중요하다
사람마다 논리적 관계를 다르게 생각함
let을 사용하면 같은 함수 내에서도 블럭 단위로 스코프를 잡을 수 있다
좋은 코드 여부와 표준 여부는 별도의 이야기
매개변수의 개수를 늘려서, 함수 내부에 하드코딩된 부분을 없애도록 할 것
반환해줄 때, 변수에 담아 반환해줘서 디버깅시 확인하기 용이하게 할 것
함수에 대한 간단한 설명을 주석에 담아 기재
일단은 인간이 이해할 수 있는 코드를 짜는 것이 먼저입니다
변수를 아낌없이 만드세요

초기화, 조건식, 증감
1. 무조건 초기화를 한 번 실행함
2. 참인지 여부 검사
3. 증감식 적용
4. continue를 쓰면 조건식으로 돌아간다

i++ 외에는 잘 안 씁니다

왜 배열은 0부터 시작하는가?

잘 하려면 쉽게 생각해야 한다

어떻게 동작하는가?
메소드가 무엇을 반환하는가?
원래의 배열에 변화가 생기는가?

indexOf
- indexOf(searchElement, fromIndex) 
- 인덱스 숫자 (fromIndex가 검색출발시작점, 검색출발시작점 이후로 없으면 -1)
- 그렇지 않다
slice
- slice(beingIndex, endIndex)
- beginIndex부터 endIndex전까지의 배열 요소를 가진 새로운 배열
- 그렇지 않다
- endIndex가 beginIndex보다 커야만 제대로 동작한다
splice
- splice(start, deleteCount, item)
- delete 배열 요소를 가진 새로운 배열
- 바꾼다

MDN 사이트 읽는 법
- Description
- Example + DevTool
- Syntax
- Parameter
- ReturnValue

프로토타입 : 내장 메소드 집합

늘 리턴값과 기존 데이터에 변화를 가하는지 여부를 확인해야 한다

함수는 늘 직관적이어야 한다
반환값을 알고 써야 한다
난 추출만 하고 싶었는데, 원래 값이 바뀐다든지의 상황을 피해야 한다
외우지 말고 찾아서 보고 쓰면서 익힐 것

function test(parameter) {
  pass;
}

test(para);

JS는 함수를 정의할 때 파라미터를 정의하지 않았어도 입력받아서 활용할 수 있다
JS는 a[100] = 100; 등을 선언하면 a의 length는 101