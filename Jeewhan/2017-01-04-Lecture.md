---
layout: post
title:  "CodeSquad"
date:   2017-01-09 21:17:00 +0900
---

# 코드스쿼드

```
잘 하기 위한 방법

- 배운 것을 가지고 다른 것을 계속 만들기
- 중학생 동생과 그 분야의 대가 앞에서 설명해보기
- 금요일도 와서 공부할 수 있으니 열심히 공부할 것

커뮤니케이션 채널

- 강의 카페 - Schololgy
- 커뮤니케이션 - Slack
- 온라인 Q&A - Piazza
- 프로젝트 관리  - Github

질문하는 방법

- 질문하기 전 3번 정도 다른 시도
- 질문하기 전 검색 ( 구글, 스택오버플로우 )
- 그 후 질문 ( 내뱉기 전 한 번 읽어볼 것 )
  - 구체적이고 명확한 질문 제목
  - 자세한 상황 설명 ( 플랫폼, 운영체제, 사용 언어 )
  - 소스코드는 gist, pastebin
  - 맞춤법 + 예의 바르게는 기본
  - 질문을 올렸다면 추적할 것

매일 공부해야 할 것들

- 영어/코딩/운동/독서

마스터들 닉네임

- 크롱(Front)
- 호눅스(Common, Back)
- JK(iOS)
```

---

### 170102

##### 리눅스 명령어

```
리눅스 커널의 다양한 배포판이 있음, 국내에서 가장 많이 쓰이는 것은 Ubuntu

history로 확인한 뒤, !1105 를 입력하면 그 번호에 해당하는 명령어를 다시 동작시킬 수 있음

say "hello" 하면 hello 라고 소리가 난다

echo "Hello" > Hello.txt

cat 파일 내용 표시

ctrl + U 를 누르면 명령줄을 삭제할 수 있다

find ‐name "파일 이름" : 파일명 검색

vim adventures

자연적 소리 sound
인위적 소리 audio

1 켜짐, 0 꺼짐
AND 곱, OR 합

코드 = 숫자

CS와 별도로 내가 관심있어하는 도메인을 가지고 있는 것이 좋음

이곳이 학원이 아니라 직장(베이스캠프)이라고 생각할 것

내 성장의 동력은 나

내가 무엇을 하고 싶은지에 대한 목표점에 관한 큰 그림을 스스로 그려나가야 함

해보지 않으면 알 수 없는 것들 투성이
```
---

### 170103

```
브라우저에서 지원되지 않으면 비표준(=플래시 같은)
플러그인을 설치해야 활용할 수 있음

뒤에 example 또는 tutorial 을 넣어서 검색하는 것도 방법 (simple 등)

역시 MDN이 좋다 (검색어에 mdn 넣을 것)
영어로 읽는 습관을 들여라

우선 코드 -> 서머리부터 읽어볼 것
그 후 바로 코드를 실행해보면서 이해할 것

디버깅을 위해서 개발자 도구 활용
=> 에러가 무엇인지 명확히 알려줌

문제가 생기면 바로 검색을 하라

깃헙주소와 더불어, 스택오버플로우 내역을 요구하는 해외 기업도 있음

parser를 통해 코드를 문자 단위로 잘게 나눔
그것을 기반으로 컴퓨터가 해석할 수 있도록 변환 bytecode
그걸 해석하면서 출력 interpreter

생각보다 null, undefined가 중요하다

javascript type check 로 검색해보면, typeof 의 한계를 알게 된다

문자열은 ""을 쓸 것

오류를 무시하지 말고, 찬찬히 들여다볼 것
오류 내용을 이해하라

소프트웨어 공학 두 개의 축 : 테스트 / 프로세스(개발 방법론, 협업)

테스트 자동화를 잘 하면 면접 때 대단한 플러스 요인

방법보다 방법론이 왜 나왔는지가 중요하다

당장 문제가 발생하지 않더라도, 잠재적 오류가 있을 수 있다
의도한 것이 아닌데, 오류를 내뱉지 않는 경우도 있다(버그의 일종)

포괄적인 의미의 디자인을 우선시하라
디자인 & 코드 ( 설계 )

변수선언, 사칙연산

console.log prints the element in an HTML-like tree
console.dir prints the element in a JSON-like tree

console은 객체이다

{} : 브레이스

아무 생각없이 메소드를 사용하지 말 것
왜 console이 필요한가?

JS에서는 네임스페이스를 객체로 표현함 ( 객체의 활용방안 )
충돌을 방지하기 위한 이름 공간 구획

console.log("a 더하기 b는 이것입니다. " + c);

c 를 type casting 해서 오류가 나오지 않은 것 ( 암묵적 형변환 )
JS의 특징이다

연산자 우선순위

type casting을 외우려고 하지 말고 그저 느껴서 익힐 것

JS의 모든 함수는 결과값을 리턴하는데, 그것이 정의되어있지 않으면 undefined 반환

jsbin.com
codepen.io

동적 타이핑
dynamic type

arguments.length

에러는 가능한 일찍 출력해줄 것

디버깅을 위해서는 정해진 메소드일지라도 변수에 담아두는 것이 좋다

함수 내 기능 코드가 너무 길어질 경우, 함수로 독립시켜서 만들 것

오류상황을 위로 올릴 것

로직 안에 데이터가 들어가있어선 안 된다 (메시지 등)

debugger; 를 추가하고, scope란을 확인해볼 것
브레이크 포인트를 찍고 함수를 돌려봐서 확인할 수도 있다
(인터프리터 언어다보니, 컴파일 과정이 없어서, 브레이크 포인트로 확인하는 과정이 많이 필요하다)

읽기 좋은 코드, 네이밍이 좋은 코드가 되기 위해 계속 지우고 새로 만들어볼 것

If 안 if를 없애라
```

---

### 170104
```
일급함수 일급객체에 대해서 조사해볼 것

결합도가 낮은 코드가 좋은 코드이다

함수를 최대한 작게 담백하게

같은 것을 여러 번 다시 짜는 것이 참 좋습니다
매번 설계를 새로 하면서 코드가 점점 더 좋아집니다

남들에게 설명했을 때 이해가 잘 되는 코드가 좋은 코드입니다

펑션을 잘 이해하고 있느냐가 중요한 실력 평가의 척도

함수 결과의 true false를 변수에 담아서 보여주게 되면, 디버깅할 때 보다 수월하다

Stack이 무엇인가?

크롬 개발자 도구를 통해 디버깅하는 습관을 들이세요

디버깅을 하면서 자바스크립트를 익히세요

함수를 변수에 담을 수 있고, 반환할 수 있다

네임스페이스는 객체에 쓰는 표현

전역변수는 window라는 객체에 담긴다

전역변수를 쓰지 말고, 필요에 따라서 지역변수를 쓰거나 매개변수로 넘겨주는 것이 좋다

함수 안에 함수가 있을 때, 안쪽 함수에서는 바깥 함수의 변수에 접근할 수 있지만, 바깥 함수에서는 안쪽 함수의 변수에 접근할 수 없다
스코프 체인(제일 가까운 스코프에서 찾는 변수가 없으면 바로 위 스코프로 가서 찾아본다)

오늘 배운 내용 : 디버깅, 스코프
```

##### 프로젝트별로 깃헙 계정을 다르게 쓰는 방법
```
git config user.name Eclatant
git config user.email distinct19@gmail.com
위 명령어 입력을 통해 계정을 수정한 후,

.git/config url에서 github.com 앞에 아이디를 추가해야 함 ( ex url : https://Eclatant@github.com/Eclatant )
```

---

### 170105

```
토큰 : 파싱하기 위해 잘라진 하나 하나의 요소
JS는 타입이 없는 것이 아니라 나중에 결정되는 것이다
문자열, 숫자, boolean, array, 배열, 오프젝트, null, regularExpression, function 등
마법같이 자동으로 되는 것은 없다
키워드와 예약어를 외우지 말고, 활용하다가 디버깅 과정으로 체득할 것
주석은 남들에게 코드로 전달하기 어려운 코드일 때만 부가적으로 필요하다 (분명한 이유가 필요하다)
프로세스의 분리를 위해서 함수가 필요한 때도 있다 (if 또는 for문을 줄이는 등, 의존성 약화)
핵심을 반영한 함수명으로 커버되지 않는 범위일 때 다른 함수로 독립시킨다
줄 수보다 과정이 핵심이다, 길더라도 의미적으로 쉽게 파악되는 것이 훨씬 중요하다
사람마다 논리적 관계를 다르게 생각함
let을 사용하면 같은 함수 내에서도 블럭 단위로 스코프를 잡을 수 있다
좋은 코드 여부와 표준 여부는 별도의 이야기
매개변수의 개수를 늘려서, 함수 내부에 하드코딩된 부분을 없애도록 할 것
반환해줄 때, 변수에 담아 반환해줘서 디버깅시 확인하기 용이하게 할 것
함수에 대한 간단한 설명을 주석에 담아 기재
일단은 인간이 이해할 수 있는 코드를 짜는 것이 먼저입니다
변수를 아낌없이 만드세요

초기화, 조건식, 증감
1. 무조건 초기화를 한 번 실행함
2. 참인지 여부 검사
3. 증감식 적용
4. continue를 쓰면 조건식으로 돌아간다

i++ 외에는 잘 안 씁니다

왜 배열은 0부터 시작하는가?

잘 하려면 쉽게 생각해야 한다

어떻게 동작하는가?
메소드가 무엇을 반환하는가?
원래의 배열에 변화가 생기는가?

indexOf
- indexOf(searchElement, fromIndex)
- 인덱스 숫자 (fromIndex가 검색출발시작점, 검색출발시작점 이후로 없으면 -1)
- 그렇지 않다
slice
- slice(beingIndex, endIndex)
- beginIndex부터 endIndex전까지의 배열 요소를 가진 새로운 배열
- 그렇지 않다
- endIndex가 beginIndex보다 커야만 제대로 동작한다
splice
- splice(start, deleteCount, item)
- delete 배열 요소를 가진 새로운 배열
- 바꾼다

MDN 사이트 읽는 법
- Description
- Example + DevTool
- Syntax
- Parameter
- ReturnValue

프로토타입 : 내장 메소드 집합

늘 리턴값과 기존 데이터에 변화를 가하는지 여부를 확인해야 한다

함수는 늘 직관적이어야 한다
반환값을 알고 써야 한다
난 추출만 하고 싶었는데, 원래 값이 바뀐다든지의 상황을 피해야 한다
외우지 말고 찾아서 보고 쓰면서 익힐 것

function test(parameter) {
  pass;
}

test(para);

JS는 함수를 정의할 때 파라미터를 정의하지 않았어도 입력받아서 활용할 수 있다
JS는 a[100] = 100; 등을 선언하면 a의 length는 101
```

### 170109

# Learn Git
## 주요 단어

- Working directory : 작업 디렉토리
- Staging area : Local repository로 올리기 전에 이번 커밋과 관련된 파일들을 관리하는 것
- Local repository : Remote repository로 Push하기 전에 관리하는 곳

## 명령어

- git init : 해당 Working directory을 깃에 등록함
- git add : Working directory의 변경사항을 Staging area에 등록
- git commit : Staging area의 사항들을 Local repository에 등록
- git push : Local repository의 사항들을 Remote repository에 등록
- git clone : Remote repository를 Working directory로 복사하면서 remote로 등록
- git pull : git fetch + git merge, Push한 이후의 변경내용을 가져옴
- git fetch : Remote repository를 Local repository로 가져옴
- git merge : Local repository를 Working directory로 가져옴

자동으로 병합되지 않는 conflict시에는 merge 또는 rebase를 사용할 것


git config --global --edit

서버의 중요한 특징
- 가용성 : 연중무휴로 사용가능
- 내구성 : 저장된 데이터가 사라지면 안 된다

내구성이 더 중요하며, 가용성은 서비스의 특징에 따라 다르다

프로젝트별로 git 세팅을 바꿀 수도 있음
git config --edit
git config user.name / git config user.email

커밋 메시지 첫 글자는 대문자, 첫 단어는 동사 현재형으로 할 것

git status
working directory와 staging area간 차이와 staging area에 올려놓은 파일들을 보여준다

git clean
local 저장소와 작업 디렉토리를 일치시킴

로컬 저장소는 커밋의 집합

git remote add origin https://Eclatant@github.com/Eclatant/TestRepository.git
잘못 설정했다면 git config --edit
cat .git/config 로도 확인가능

git push --set-upstream origin master

git reset --hard HEAD

git clone
임의의 디렉토리 만들고 로컬 저장소로 가져오고, 워킹 디렉토리에 최신내용 반영
git clone 명령 맨 뒤에 폴더명을 입력하면 원하는 폴더명으로 가져올 수 있음
git clone abc abcd 라고 하면 로컬 저장소 abc와 작업 디렉토리를 복사해옴

git checkout commit-id file : 해당 file만 커밋시점으로 되돌아감, file이 없으면 전체가 되돌아감

Already up-to-date : 원격 저장소와 로컬 저장소와 작업 디렉토리 모두가 일치함

git commit -am : git add 와 git commit을 합침

Tree와 Graph의 차이는 합쳐지냐 안 합쳐지냐이다

origin/HEAD : 최신
HEAD는 현재 작업 디렉토리

git branch -r : 원격 브랜치 목록
git remote -v : 원격 저장소 이름이 어떤 원격 저장소를 가리키고 있는지 확인가능
git push 원격저장소 브랜치이름 이 기본(생략하면 git push origin master)
git push --set-upstream origin master :  origin/master를 지금 브랜치의 원격저장소로 연결시키겠다

upstream : local에 연결된 원격 저장소

git branch feature : 현재 브랜치를 따와서 feature 브랜치를 생성
Master는 배포용으로 가장 완벽한 브랜치로 유지되어야 한다
서비스 개발시에는 develop브랜치를 따와서 그것에서 다른 기능에 해당하는 branch를 따와서 작업하다가 develop으로 merge해주고 검증 후에 master에 merge해서 배포해준다

checkout을 commit으로 할 수도 있다
checkout : 현재 작업 디렉토리를 바꿔주는 명령
HEAD도 origin/master는 해당 커밋시점을 가리키는 것

git log는 시간 순서대로 표시된다
merge는 head와 합치는 것

git reset 시에 staging area에 올려놓은 것은 날아간다

collaborator 가 없으면 origin/head 가 안 나오는 이유

우리는 과학자가 아닌 엔지니어이다
알려고 고민하는 시간을 1시간 이상 들이지 마세요

git checkout 2e4a153 -b event : 해당 커밋에서 브랜치를 생성하고 체크아웃

새로 클론해오면 마스터와 HEAD만 존재

origin/master 와 origin/head는 항상 기본적으로 같지만 설정에서 변경할 수 있음

git checkout origin/feature-1 -b feature-1 : origin/feature-1 을 feature-1으로 만들어줘

git checkout develop : remote에 develop이 있으면 가져와줘

head 브랜치는 삭제할 수 없어요
삭제하려는 브랜치에만 속해있는 커밋이 있다면 에러가 발생 (다른 곳으로 이전해줘!)
branch -d 옵션일 때만 가능

echo "zzz" >> copy.js
\>\> 쓰면 파일 밑에 덧붙이는 효과

git branch -D branchname 강제로 브랜치를 삭제

브랜치는 한 커밋을 가리키고 있는 것이고, 그것은 과거 이력을 모두 가지고 있다 (포인터)
깃은 커밋 외에는 모두 허상에 가까움

alias glogs='git log --oneline --graph --decorate --all'
alias glogs='git log --oneline --graph --decorate' 를 일반적으로 더 많이 사용 (내 작업을 보기 위해서)

\`\`\`node

```

# Learn Git
## 주요 단어

- Working directory : 작업 디렉토리
- Staging area : Local repository로 올리기 전에 이번 커밋과 관련된 파일들을 관리하는 것
- Local repository : Remote repository로 Push하기 전에 관리하는 곳

## 명령어

- git init : 해당 Working directory을 깃에 등록함
- git add : Working directory의 변경사항을 Staging area에 등록
- git commit : Staging area의 사항들을 Local repository에 등록
- git push : Local repository의 사항들을 Remote repository에 등록
- git clone : Remote repository를 Working directory로 복사하면서 remote로 등록
- git pull : git fetch + git merge, Push한 이후의 변경내용을 가져옴
- git fetch : Remote repository를 Local repository로 가져옴
- git merge : Local repository를 Working directory로 가져옴

자동으로 병합되지 않는 conflict시에는 merge 또는 rebase를 사용할 것
```

switch문을 활용하여 동시에 여러가지 경우 적용

```javascript
//월 마지막 일자 반환

function daysInMonth( month ){
	switch (month) {
    case 2:
      return 28;
    case (month % 2 === 0):
    case 9:
      return 30;
    default :
      return 31;
  }
}
```

---

##### 170110

**함수의 스코프는 선언될 때 결정된다 (실행될 때가 아니다)**
**코드가 빨리 if문에서 벗어나도록 하라**
**특정 라인을 읽었을 때, 복잡한 생각이 들지 않도록 하라**

MDN의 폴리필은 해당 메소드가 지원되지 않을 경우, 대체안 (하위 버전 호환성)

타입, 객체, This 등이 어려운 요소

!!1 : 1은 트루인가?
뒤에 있는 요소의 T/F 여부를 판단해줌
undefined, null, NaN, "", 0 

forEach 와 map의 차이를 모르겠다.
=> forEach : 각각의 array의 요소에 ( )안의 함수를 일괄 적용시키는 함수
=> map : 각각의 array의 요소에 ( )안의 함수를 일괄 적용시켜 새로운 배열을 만드는 함수
filter는 해당 배열에 조건을 충족시키는 요소들만 담긴 배열을 반환받고 싶을 때 쓰는 것

자료형마다 call by value 와 call by reference가 나뉘어있음
(java의 철학은 javascript가 그대로 가져옴)

건축과 소프트웨어 개발은 유사성이 많다

JS 디스트럭쳐를 공부해볼 것

맵 : 같은 차원의 다른 값으로 바꾸는 것
리듀스 : 차원을 낮추는 것

개인 프로젝트는 질보다 양을 많이 본다

```

var newContent = {"id" : 88, "name" : "crong", "content" : ["새로운글"], "like" : 5, "comment" : ["댓글이다"]};

function appendContent(str, obj) {
	obj["content"].push(str);
}

appendContent("어서오세요!", newContent);

console.log(newContent["content"]);

function removeContent(obj, key) {
	delete obj[key];
}

removeContent(newContent, "id");

console.log(newContent);

function isContent(obj, key) {
	return obj.hasOwnProperty(key);
}

console.log(isContent(newContent, "id"));

newObj.forEach(console.log);

for (var i = 0; i < newObj.length; i++) {
	console.log(newObj[Object.keys(newObj)[i]]);
}
```
